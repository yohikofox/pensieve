/**
 * DigestionJobConsumer Integration Tests
 * Tests for Task 5.6: Full digestion flow integration
 *
 * Tests the complete flow from job reception to Thought/Ideas creation
 * Uses real service implementations (not mocks) where possible
 */

import { Test, TestingModule } from '@nestjs/testing';
import { DigestionJobConsumer } from './digestion-job-consumer.service';
import { ProgressTrackerService } from '../services/progress-tracker.service';
import { QueueMonitoringService } from '../services/queue-monitoring.service';
import { EventBusService } from '../services/event-bus.service';
import { ContentExtractorService } from '../services/content-extractor.service';
import { ContentChunkerService } from '../services/content-chunker.service';
import { OpenAIService } from '../services/openai.service';
import { ThoughtRepository } from '../repositories/thought.repository';
import { Thought } from '../../domain/entities/thought.entity';
import { Idea } from '../../domain/entities/idea.entity';
import type { DigestionJobPayload } from '../../domain/interfaces/digestion-job-payload.interface';

describe('DigestionJobConsumer Integration Tests (Task 5.6)', () => {
  let consumer: DigestionJobConsumer;
  let contentExtractor: ContentExtractorService;
  let contentChunker: ContentChunkerService;
  let thoughtRepository: ThoughtRepository;
  let eventBus: EventBusService;
  let captureRepository: any;

  // Captured events for verification
  let publishedEvents: Array<{ event: string; payload: any }> = [];

  beforeEach(async () => {
    publishedEvents = [];

    // Mock capture repository
    const mockCaptureRepository = {
      findById: jest.fn().mockResolvedValue({
        id: 'capture-123',
        userId: 'user-456',
        type: 'text',
        content: 'Test content for digestion',
        status: 'transcribed',
      }),
      updateStatus: jest.fn().mockResolvedValue(undefined),
    };

    // Mock OpenAI service for deterministic responses
    const mockOpenAIService = {
      digestContent: jest.fn().mockResolvedValue({
        summary:
          'This is a test summary generated by GPT for the content provided.',
        ideas: [
          'First key idea extracted from the content',
          'Second important insight about the topic',
          'Third actionable point identified',
        ],
        confidence: 'high',
      }),
    };

    // Mock event bus to capture events
    const mockEventBus = {
      publish: jest.fn((event: string, payload: any) => {
        publishedEvents.push({ event, payload });
      }),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        DigestionJobConsumer,
        {
          provide: ProgressTrackerService,
          useValue: {
            startTracking: jest.fn(),
            updateProgress: jest.fn(),
            completeTracking: jest.fn(),
            failTracking: jest.fn(),
          },
        },
        {
          provide: QueueMonitoringService,
          useValue: {
            recordJobProcessed: jest.fn(),
            recordJobFailed: jest.fn(),
            recordJobLatency: jest.fn(),
          },
        },
        {
          provide: 'CAPTURE_REPOSITORY',
          useValue: mockCaptureRepository,
        },
        {
          provide: EventBusService,
          useValue: mockEventBus,
        },
        {
          provide: ContentExtractorService,
          useValue: {
            extractContent: jest.fn().mockResolvedValue({
              content: 'Test content for digestion flow integration test',
              contentType: 'text',
            }),
          },
        },
        {
          provide: ContentChunkerService,
          useValue: {
            processContent: jest
              .fn()
              .mockImplementation(async (content, contentType) => {
                // Simulate calling OpenAI
                return mockOpenAIService.digestContent(content, contentType);
              }),
          },
        },
        {
          provide: OpenAIService,
          useValue: mockOpenAIService,
        },
        {
          provide: ThoughtRepository,
          useValue: {
            createWithIdeas: jest
              .fn()
              .mockImplementation(
                async (
                  captureId,
                  userId,
                  summary,
                  ideas,
                  processingTimeMs,
                  confidenceScore,
                ) => {
                  const thought: Thought = {
                    id: 'thought-123',
                    captureId,
                    ownerId: userId,
                    summary,
                    confidenceScore,
                    processingTimeMs,
                    statusId: 'd0000000-0000-7000-8000-000000000001',
                    lastModifiedAt: Date.now(),
                    ideas: [],
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    deletedAt: null,
                  };
                  return thought;
                },
              ),
          },
        },
      ],
    }).compile();

    consumer = module.get<DigestionJobConsumer>(DigestionJobConsumer);
    contentExtractor = module.get<ContentExtractorService>(
      ContentExtractorService,
    );
    contentChunker = module.get<ContentChunkerService>(ContentChunkerService);
    thoughtRepository = module.get<ThoughtRepository>(ThoughtRepository);
    eventBus = module.get<EventBusService>(EventBusService);
    captureRepository = module.get('CAPTURE_REPOSITORY');
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Full Digestion Flow (Task 5.6)', () => {
    it('should complete full digestion flow from job to Thought creation', async () => {
      // Arrange
      const job: DigestionJobPayload = {
        captureId: 'capture-123',
        userId: 'user-456',
        contentType: 'text',
        priority: 'normal',
        queuedAt: new Date(),
        retryCount: 0,
      };

      // Act
      await consumer.handleDigestionJob(job);

      // Assert - Verify complete flow
      // 1. Content extracted
      expect(contentExtractor.extractContent).toHaveBeenCalledWith(
        'capture-123',
      );

      // 2. Content processed with chunker (calls OpenAI)
      expect(contentChunker.processContent).toHaveBeenCalledWith(
        expect.any(String),
        'text',
      );

      // 3. Thought and Ideas created
      expect(thoughtRepository.createWithIdeas).toHaveBeenCalledWith(
        'capture-123',
        'user-456',
        expect.stringContaining('summary'),
        expect.arrayContaining([expect.any(String)]),
        expect.any(Number), // processingTimeMs
        0.9, // high confidence = 0.9
      );

      // 4. Capture status updated to digesting then digested
      expect(captureRepository.updateStatus).toHaveBeenCalledWith(
        'capture-123',
        'digesting',
        expect.any(Object),
      );

      // 5. Events published
      const startedEvent = publishedEvents.find(
        (e) => e.event === 'digestion.job.started',
      );
      expect(startedEvent).toBeDefined();
      expect(startedEvent!.payload).toMatchObject({
        captureId: 'capture-123',
        userId: 'user-456',
      });

      const completedEvent = publishedEvents.find(
        (e) => e.event === 'digestion.completed',
      );
      expect(completedEvent).toBeDefined();
      expect(completedEvent!.payload).toMatchObject({
        thoughtId: 'thought-123',
        captureId: 'capture-123',
        userId: 'user-456',
        ideasCount: 3,
      });
    });

    it('should handle audio capture digestion flow', async () => {
      // Arrange
      (contentExtractor.extractContent as jest.Mock).mockResolvedValueOnce({
        content: 'Transcribed audio content about project ideas',
        contentType: 'audio',
      });

      const job: DigestionJobPayload = {
        captureId: 'audio-capture-456',
        userId: 'user-789',
        contentType: 'audio_transcribed',
        priority: 'high',
        queuedAt: new Date(),
        retryCount: 0,
      };

      // Act
      await consumer.handleDigestionJob(job);

      // Assert
      expect(contentExtractor.extractContent).toHaveBeenCalledWith(
        'audio-capture-456',
      );
      expect(contentChunker.processContent).toHaveBeenCalledWith(
        expect.stringContaining('audio'),
        'audio',
      );
      expect(thoughtRepository.createWithIdeas).toHaveBeenCalled();
    });

    it('should propagate errors through the flow', async () => {
      // Arrange
      (contentExtractor.extractContent as jest.Mock).mockRejectedValueOnce(
        new Error('Content extraction failed: empty transcription'),
      );

      const job: DigestionJobPayload = {
        captureId: 'failing-capture',
        userId: 'user-123',
        contentType: 'audio_transcribed',
        priority: 'normal',
        queuedAt: new Date(),
        retryCount: 0,
      };

      // Act & Assert
      await expect(consumer.handleDigestionJob(job)).rejects.toThrow(
        'Content extraction failed',
      );

      // Should NOT create Thought if extraction fails
      expect(thoughtRepository.createWithIdeas).not.toHaveBeenCalled();
    });

    it('should handle low confidence responses correctly', async () => {
      // Arrange
      (contentChunker.processContent as jest.Mock).mockResolvedValueOnce({
        summary: 'Buy milk',
        ideas: ['Short content'],
        confidence: 'low',
      });

      const job: DigestionJobPayload = {
        captureId: 'short-capture',
        userId: 'user-123',
        contentType: 'text',
        priority: 'normal',
        queuedAt: new Date(),
        retryCount: 0,
      };

      // Act
      await consumer.handleDigestionJob(job);

      // Assert - Low confidence should map to 0.3
      expect(thoughtRepository.createWithIdeas).toHaveBeenCalledWith(
        'short-capture',
        'user-123',
        'Buy milk',
        ['Short content'],
        expect.any(Number),
        0.3, // low confidence = 0.3
      );
    });

    it('should record processing time in Thought entity', async () => {
      // Arrange
      const job: DigestionJobPayload = {
        captureId: 'timed-capture',
        userId: 'user-123',
        contentType: 'text',
        priority: 'normal',
        queuedAt: new Date(),
        retryCount: 0,
      };

      // Act
      await consumer.handleDigestionJob(job);

      // Assert - Verify processing time is recorded
      const createCall = (thoughtRepository.createWithIdeas as jest.Mock).mock
        .calls[0];
      const recordedProcessingTime = createCall[5]; // processingTimeMs argument

      // Processing time should be a positive number (AC4 requirement)
      expect(recordedProcessingTime).toBeGreaterThan(0);
      expect(typeof recordedProcessingTime).toBe('number');

      // Should be reasonable (less than 10 seconds for a test)
      expect(recordedProcessingTime).toBeLessThan(10000);
    });
  });

  describe('Error Handling Integration (Task 5.6)', () => {
    it('should update capture status to digestion_failed after max retries', async () => {
      // Arrange
      (contentChunker.processContent as jest.Mock).mockRejectedValue(
        new Error('GPT API timeout'),
      );

      const job: DigestionJobPayload = {
        captureId: 'retry-capture',
        userId: 'user-123',
        contentType: 'text',
        priority: 'normal',
        queuedAt: new Date(),
        retryCount: 2, // 3rd attempt (0-indexed)
      };

      // Act & Assert
      await expect(consumer.handleDigestionJob(job)).rejects.toThrow(
        'GPT API timeout',
      );

      // Should update status to failed after max retries
      expect(captureRepository.updateStatus).toHaveBeenCalledWith(
        'retry-capture',
        'digestion_failed',
        expect.objectContaining({
          error_message: 'GPT API timeout',
        }),
      );

      // Should publish failed event
      const failedEvent = publishedEvents.find(
        (e) => e.event === 'digestion.job.failed',
      );
      expect(failedEvent).toBeDefined();
    });

    it('should not update to failed status before max retries', async () => {
      // Arrange
      (contentChunker.processContent as jest.Mock).mockRejectedValue(
        new Error('Temporary error'),
      );

      const job: DigestionJobPayload = {
        captureId: 'retry-capture-1',
        userId: 'user-123',
        contentType: 'text',
        priority: 'normal',
        queuedAt: new Date(),
        retryCount: 1, // 2nd attempt (still has one more retry)
      };

      // Act & Assert
      await expect(consumer.handleDigestionJob(job)).rejects.toThrow(
        'Temporary error',
      );

      // Should NOT update to digestion_failed yet
      const failedStatusCalls = (
        captureRepository.updateStatus as jest.Mock
      ).mock.calls.filter((call) => call[1] === 'digestion_failed');
      expect(failedStatusCalls).toHaveLength(0);
    });
  });
});
